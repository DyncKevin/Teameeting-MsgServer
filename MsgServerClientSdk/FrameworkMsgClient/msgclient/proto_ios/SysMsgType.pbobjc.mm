// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sys_msg_type.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "SysMsgType.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - SysMsgTypeRoot

@implementation SysMsgTypeRoot

@end

#pragma mark - Enum ETransferModule

GPBEnumDescriptor *ETransferModule_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Mconnector\000Mmsgqueue\000Mmeeting\000Mp2P\000Mlive"
        "\000Mcallcenter\000Mlogical\000Msequence\000Mstorage"
        "\000Mgrpnotify\000Mpusher\000";
    static const int32_t values[] = {
        ETransferModule_Mconnector,
        ETransferModule_Mmsgqueue,
        ETransferModule_Mmeeting,
        ETransferModule_Mp2P,
        ETransferModule_Mlive,
        ETransferModule_Mcallcenter,
        ETransferModule_Mlogical,
        ETransferModule_Msequence,
        ETransferModule_Mstorage,
        ETransferModule_Mgrpnotify,
        ETransferModule_Mpusher,
    };
    static const char *extraTextFormatInfo = "\001\003b\002\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ETransferModule)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ETransferModule_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ETransferModule_IsValidValue(int32_t value__) {
  switch (value__) {
    case ETransferModule_Mconnector:
    case ETransferModule_Mmsgqueue:
    case ETransferModule_Mmeeting:
    case ETransferModule_Mp2P:
    case ETransferModule_Mlive:
    case ETransferModule_Mcallcenter:
    case ETransferModule_Mlogical:
    case ETransferModule_Msequence:
    case ETransferModule_Mstorage:
    case ETransferModule_Mgrpnotify:
    case ETransferModule_Mpusher:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ETransferType

GPBEnumDescriptor *ETransferType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Tconn\000Ttrans\000Tqueue\000Tdispatch\000Tpush\000Tlog"
        "in\000Tlogout\000TwriteRequest\000TwriteResponse\000"
        "TreadRequest\000TreadResponse\000Terror\000";
    static const int32_t values[] = {
        ETransferType_Tconn,
        ETransferType_Ttrans,
        ETransferType_Tqueue,
        ETransferType_Tdispatch,
        ETransferType_Tpush,
        ETransferType_Tlogin,
        ETransferType_Tlogout,
        ETransferType_TwriteRequest,
        ETransferType_TwriteResponse,
        ETransferType_TreadRequest,
        ETransferType_TreadResponse,
        ETransferType_Terror,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ETransferType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ETransferType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ETransferType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ETransferType_Tconn:
    case ETransferType_Ttrans:
    case ETransferType_Tqueue:
    case ETransferType_Tdispatch:
    case ETransferType_Tpush:
    case ETransferType_Tlogin:
    case ETransferType_Tlogout:
    case ETransferType_TwriteRequest:
    case ETransferType_TwriteResponse:
    case ETransferType_TreadRequest:
    case ETransferType_TreadResponse:
    case ETransferType_Terror:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ETransferPriority

GPBEnumDescriptor *ETransferPriority_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Plow\000Pnormal\000Phigh\000";
    static const int32_t values[] = {
        ETransferPriority_Plow,
        ETransferPriority_Pnormal,
        ETransferPriority_Phigh,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ETransferPriority)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ETransferPriority_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ETransferPriority_IsValidValue(int32_t value__) {
  switch (value__) {
    case ETransferPriority_Plow:
    case ETransferPriority_Pnormal:
    case ETransferPriority_Phigh:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ETransferFlag

GPBEnumDescriptor *ETransferFlag_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Fnoack\000Fneedack\000Fack\000";
    static const int32_t values[] = {
        ETransferFlag_Fnoack,
        ETransferFlag_Fneedack,
        ETransferFlag_Fack,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ETransferFlag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ETransferFlag_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ETransferFlag_IsValidValue(int32_t value__) {
  switch (value__) {
    case ETransferFlag_Fnoack:
    case ETransferFlag_Fneedack:
    case ETransferFlag_Fack:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ETransferTag

GPBEnumDescriptor *ETransferTag_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Seqn\000Data\000";
    static const int32_t values[] = {
        ETransferTag_Seqn,
        ETransferTag_Data,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ETransferTag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ETransferTag_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ETransferTag_IsValidValue(int32_t value__) {
  switch (value__) {
    case ETransferTag_Seqn:
    case ETransferTag_Data:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EConnTag

GPBEnumDescriptor *EConnTag_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Thi\000Thello\000Thellohi\000Tkeepalive\000";
    static const int32_t values[] = {
        EConnTag_Thi,
        EConnTag_Thello,
        EConnTag_Thellohi,
        EConnTag_Tkeepalive,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EConnTag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EConnTag_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EConnTag_IsValidValue(int32_t value__) {
  switch (value__) {
    case EConnTag_Thi:
    case EConnTag_Thello:
    case EConnTag_Thellohi:
    case EConnTag_Tkeepalive:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EConnType

GPBEnumDescriptor *EConnType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ttcp\000Thttp\000";
    static const int32_t values[] = {
        EConnType_Ttcp,
        EConnType_Thttp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EConnType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EConnType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EConnType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EConnType_Ttcp:
    case EConnType_Thttp:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
